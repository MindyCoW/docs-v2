"use strict";(self.webpackChunkcow_docs=self.webpackChunkcow_docs||[]).push([[7093],{72445:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var s=n(85893),a=n(11151);const o={},r="Approving the tokens to sell",c={id:"tutorials/cowswap-trades-with-a-gnosis-safe-wallet/approving-the-tokens-to-sell",title:"Approving the tokens to sell",description:"The first step is approving the tokens you want to sell to the GPv2VaultRelayer.",source:"@site/docs/tutorials/cowswap-trades-with-a-gnosis-safe-wallet/approving-the-tokens-to-sell.md",sourceDirName:"tutorials/cowswap-trades-with-a-gnosis-safe-wallet",slug:"/tutorials/cowswap-trades-with-a-gnosis-safe-wallet/approving-the-tokens-to-sell",permalink:"/docs-v2/docs/tutorials/cowswap-trades-with-a-gnosis-safe-wallet/approving-the-tokens-to-sell",draft:!1,unlisted:!1,editUrl:"https://github.com/cowprotocol/docs/tree/main/docs/tutorials/cowswap-trades-with-a-gnosis-safe-wallet/approving-the-tokens-to-sell.md",tags:[],version:"current",frontMatter:{}},i={},l=[];function p(e){const t=Object.assign({h1:"h1",p:"p",strong:"strong",code:"code",pre:"pre"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"approving-the-tokens-to-sell",children:"Approving the tokens to sell"}),"\n",(0,s.jsxs)(t.p,{children:["The first step is approving the tokens you want to sell to the ",(0,s.jsx)(t.strong,{children:"GPv2VaultRelayer"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The safe that I am using had ",(0,s.jsx)(t.code,{children:"yvUSDC"}),", ",(0,s.jsx)(t.code,{children:"yvYFI"})," and ",(0,s.jsx)(t.code,{children:"yvLINK"}),", so my first tx takes care of withdrawing and approving each token. Code is the following:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'import click\nfrom ape_safe import ApeSafe\nfrom brownie *\n\ndef withdraw_and_approve_tokens_sep_21():\n    # Get the safe\n    safe = ApeSafe("0xMySafeAddress")\n\n    # Contract we need to approve so our tokens can be transferFrom\n    gnosis_vault_relayer = safe.contract("0xC92E8bdf79f0507f65a392b0ab4667716BFE0110")\n\n    # yearn vault tokens\n    yvUSDC = safe.contract("0x5f18C75AbDAe578b483E5F43f12a39cF75b973a9")\n    yvYFI = safe.contract("0xE14d13d8B3b85aF791b2AADD661cDBd5E6097Db1")\n    yvLINK = safe.contract("0x671a912C10bba0CFA74Cfc2d6Fba9BA1ed9530B2")\n\n    for vault in [yvUSDC, yvYFI, yvLINK]:\n        print(f"Processing {vault.name()}")\n\n        # Withdraw everything from the vault\n        vault.withdraw()\n        token = safe.contract(vault.token())\n        token_balance = token.balanceOf(safe.address)\n        print(f"Balance of {token.name()}: {(token_balance / 10 ** token.decimals()):_}")\n        assert token.balanceOf(safe.address) > 0\n\n        # Approve so we can create a cowswap order\n        token.approve(gnosis_vault_relayer, 2**256-1)\n\n\n    safe_tx = safe.multisend_from_receipts()\n    account = click.prompt("signer", type=click.Choice(accounts.load()))\n    safe_tx.sign(accounts.load(account).private_key)\n    safe.preview(safe_tx, events=False, call_trace=False)\n    safe.post_transaction(safe_tx)\n'})}),"\n",(0,s.jsx)(t.p,{children:"After testing in a fork, ape-safe will ask for your account password and submit the tx to the multisign."}),"\n",(0,s.jsx)(t.p,{children:"After the tx is executed, we would have our vanilla erc-20 tokens plus all approvals needed to submit an order."})]})}const d=function(e={}){const{wrapper:t}=Object.assign({},(0,a.ah)(),e.components);return t?(0,s.jsx)(t,Object.assign({},e,{children:(0,s.jsx)(p,e)})):p(e)}},11151:(e,t,n)=>{n.d(t,{Zo:()=>c,ah:()=>o});var s=n(67294);const a=s.createContext({});function o(e){const t=s.useContext(a);return s.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const r={};function c({components:e,children:t,disableParentContext:n}){let c;return c=n?"function"==typeof e?e({}):e||r:o(e),s.createElement(a.Provider,{value:c},t)}}}]);