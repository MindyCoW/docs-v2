"use strict";(self.webpackChunkcow_docs=self.webpackChunkcow_docs||[]).push([[4868],{43634:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>n,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var o=s(85893),r=s(11151);const i={},n="Solver Auction and Rewards",a={id:"solvers/in-depth-solver-specification/solver-auction-and-rewards",title:"Solver Auction and Rewards",description:"As specified in CIP-20, solver rewards are split into two components: per-auction rewards and consistency rewards.",source:"@site/docs/solvers/in-depth-solver-specification/solver-auction-and-rewards.md",sourceDirName:"solvers/in-depth-solver-specification",slug:"/solvers/in-depth-solver-specification/solver-auction-and-rewards",permalink:"/docs-v2/docs/solvers/in-depth-solver-specification/solver-auction-and-rewards",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/solvers/in-depth-solver-specification/solver-auction-and-rewards.md",tags:[],version:"current",frontMatter:{}},c={},l=[{value:"Specification of per-auction rewards",id:"specification-of-per-auction-rewards",level:3},{value:"Solver bidding strategies",id:"solver-bidding-strategies",level:3}];function d(e){const t=Object.assign({h1:"h1",p:"p",a:"a",h3:"h3"},(0,r.ah)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"solver-auction-and-rewards",children:"Solver Auction and Rewards"}),"\n",(0,o.jsxs)(t.p,{children:["As specified in ",(0,o.jsx)(t.a,{href:"https://snapshot.org/#/cow.eth/proposal/0x2d3f9bd1ea72dca84b03e97dda3efc1f4a42a772c54bd2037e8b62e7d09a491f",children:"CIP-20"}),", solver rewards are split into two components: per-auction rewards and consistency rewards."]}),"\n",(0,o.jsx)(t.p,{children:"The auction's goal is to reward solvers based on how much value they provide to the users. For every batch, solvers compete by proposing a solution to settle the batch, and the winning solver receives a reward that is part in ETH and part in COW (see below). "}),"\n",(0,o.jsx)(t.p,{children:"CoW Protocol has committed to spending a certain amount of COW to reward solvers; this amount will be updated every six months. The part of the rewards budget in COW that is not spent on per-auction rewards is used for consistency rewards. Consistency rewards are distributed weekly to each solver in proportion to the number of valid solutions submitted during the previous week."}),"\n",(0,o.jsx)(t.h3,{id:"specification-of-per-auction-rewards",children:"Specification of per-auction rewards"}),"\n",(0,o.jsx)(t.p,{children:"The per-auction rewards are computed using a mechanism akin to a second-price auction. First, each solver commits to a numerical score and a solution (which includes a price vector and a list of trades to execute). The solver with the highest score wins the right to settle their submitted solution on chain. Note that, from the protocol perspective, the solution executed on chain must equal the solver's initial commitment. Finally, the payment to the winning solver is:"}),"\n",(0,o.jsx)(t.p,{children:"$$\n\\textrm{payment} = \\textrm{cap}(\\textrm{observedQuality} - \\textrm{referenceScore}).\n$$"}),"\n",(0,o.jsx)(t.p,{children:'Here, $$\\textrm{referenceScore}$$ is the second-highest submitted $$\\textrm{score}$$, and $$\\textrm{observedQuality}$$ is the settlement\'s "quality", as observed on chain. More precisely, in case of a successful settlement, the $$\\textrm{observedQuality}$$ is equal to the sum of the surplus generated for users and fees paid to the protocol, while in the case of a failed settlement (e.g., one that reverted), the $$\\textrm{observedQuality}$$ is zero. Note that the payment can end up being negative, in which case the solver pays the protocol.'}),"\n",(0,o.jsx)(t.p,{children:"The payment is capped from above and below using the function $$\\textrm{cap}(x) = \\max(-c, \\min(c + \\textrm{observedCost}, x))$$ with $$c = 0.01 ;\\textrm{ETH}$$, where $$\\textrm{observedCost}$$ is the gas cost of executing the settlement (which the solver pays)."}),"\n",(0,o.jsx)(t.p,{children:"Submitted scores that are non-positive will be ignored; this is enforced by always considering the empty solution, that has zero score. This also implies that, for an auction with only one submitted solution (from a solver), the reward will be $$\\textrm{cap}(\\textrm{observedQuality})$$, since the $$\\textrm{referenceScore}$$ is zero in this case."}),"\n",(0,o.jsx)(t.p,{children:"Moreover, the score a solver reports is required to be smaller than the solution's $$\\textrm{successfulQuality}$$, defined as the $$\\textrm{observedQuality}$$ when the solution successfully executes. Since solvers are currently submitting the full solution along with their score, this is very easily checked; if the solution successfully settles on chain, its $$\\textrm{successfulQuality}$$ is equal to the sum of the total surplus generated and the fees collected, and both are fully determined from the set of orders the solution intends to execute and the clearing price vector it reports."}),"\n",(0,o.jsx)(t.p,{children:"Note that once we include the gas costs of executing a transaction, the winning solver's payoff is bounded above by $$c$$. However, it is not bounded below because, in case of a revert, the solver pays at most $$c$$ to the protocol and may also incur gas costs."}),"\n",(0,o.jsx)(t.p,{children:"To limit currency mismatch, the solver receives $$\\min(\\textrm{payment}, \\textrm{observedCost})$$ in ETH and $$\\textrm{payment} - \\min(\\textrm{payment}, \\textrm{observedCost})$$ in COW, using an up-to-date price. In other words, the solver payment is split into a gas reimbursement paid in ETH and a reward paid in COW.  To arrive at the budget for consistency rewards, these per-auction rewards paid in COW are deducted from the total rewards budget."}),"\n",(0,o.jsxs)(t.p,{children:["Finally, the winning solver may pay additional costs, such as, for example, negative slippage once a solution is implemented. These costs are not an explicit element of the mechanism, but they are relevant in determining the solver's optimal strategy. More precisely, per ",(0,o.jsx)(t.a,{href:"https://snapshot.org/#/cow.eth/proposal/0xf9c98a2710dc72c906bbeab9b8fe169c1ed2e9af6a67776cc29b8b4eb44d0fb2",children:"CIP-17"}),", solvers are responsible for managing potential slippage incurred by the settlements they settle. This is a component that affects payouts, but can be treated completely separately, and we do so in ",(0,o.jsx)(t.a,{href:"https://app.gitbook.com/o/-MhNTbohYqyGgzHCBv93/s/-MfcJLF8wcqI03lmTpn8/~/changes/167/off-chain-services/in-depth-solver-specification/slippage-accounting",children:"this"})," section."]}),"\n",(0,o.jsx)(t.h3,{id:"solver-bidding-strategies",children:"Solver bidding strategies"}),"\n",(0,o.jsx)(t.p,{children:"Apart from submitting their solutions, solvers must decide on a score to submit as a bid in the auction. In general, this score can be chosen freely by the solver (within the restriction $$0 < \\textrm{score} < \\textrm{successfulQuality}$$)."}),"\n",(0,o.jsx)(t.p,{children:"Let $$p$$ the probability that a solution successfully executes, let $$SC$$ be the costs that a solver pays if only if a solution successfully executes, and $$C$$ the costs that a solver pays independently of whether a solution executes. For example, variable costs could include potential negative slippage of an executed solution, while fixed costs could include gas costs that arise even for a reverted solution."}),"\n",(0,o.jsx)(t.p,{children:"Ignoring capping, the winning solver's expected payoff is  "}),"\n",(0,o.jsx)(t.p,{children:"$$\np \\cdot (\\textrm{successfulQuality} - \\textrm{SC})  - \\textrm{referenceScore} - \\textrm{C}.\n$$"}),"\n",(0,o.jsx)(t.p,{children:"The optimal score is such that the solver wins if and only if it is profitable to do so, and is given by"}),"\n",(0,o.jsx)(t.p,{children:"$$\n\\textrm{optimalScore} = p \\cdot (\\textrm{successfulQuality} - \\textrm{SC}) -\\textrm{C}.\n$$"}),"\n",(0,o.jsx)(t.p,{children:"Accounting for the cap, the winning solver's expected payoff is now"}),"\n",(0,o.jsx)(t.p,{children:"$$\np \\cdot (\\max(-c, \\min(c + \\textrm{observedCost}, \\textrm{successfulQuality} - \\textrm{referenceScore}) - \\textrm{SC}) \\ - (1-p) \\cdot \\min(c, \\textrm{referenceScore}) - \\textrm{C}.\n$$"}),"\n",(0,o.jsx)(t.p,{children:"If there is no value of $$\\textrm{referenceScore}$$ such that the above expression is strictly positive, then a solver does not want to participate. If, instead, there are values of $$\\textrm{referenceScore}$$ such that profits are strictly positive, then the logic discussed earlier continues to apply: each solver wants to win if and only if $$\\textrm{referenceScore}$$ is such that profits are strictly positive. Since the above expression is monotonic decreasing in $$\\textrm{rereferenceScore}$$, a solver should compute the $$\\textrm{referenceScore}$$ such that the above expression is zero and submit that value as a score. Formally, the optimal score is now implicitly defined by"}),"\n",(0,o.jsx)(t.p,{children:"$$\np \\cdot (\\max(-c, min(c + \\textrm{observedCost}, \\textrm{successfulQuality} - \\textrm{optimalScore}) - \\textrm{SC}) \\ - (1-p) \\cdot \\min(c, \\textrm{optimalScore}) - \\textrm{C} = 0.\n$$"}),"\n",(0,o.jsx)(t.p,{children:"The above equation always has a solution that is independent of $$\\textrm{referenceScore}$$. This solution is, in general, unique (that is, unique except for very specific parameters, in which case the solution is a closed interval)."})]})}const h=function(e={}){const{wrapper:t}=Object.assign({},(0,r.ah)(),e.components);return t?(0,o.jsx)(t,Object.assign({},e,{children:(0,o.jsx)(d,e)})):d(e)}},11151:(e,t,s)=>{s.d(t,{Zo:()=>a,ah:()=>i});var o=s(67294);const r=o.createContext({});function i(e){const t=o.useContext(r);return o.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const n={};function a({components:e,children:t,disableParentContext:s}){let a;return a=s?"function"==typeof e?e({}):e||n:i(e),o.createElement(r.Provider,{value:a},t)}}}]);