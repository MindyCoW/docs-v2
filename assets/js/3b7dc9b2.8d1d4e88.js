"use strict";(self.webpackChunkcow_docs=self.webpackChunkcow_docs||[]).push([[8713],{35942:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>i,toc:()=>d});var n=o(85893),s=o(11151);const r={},a="Signed Orders",i={id:"overview/signed-orders",title:"Signed Orders",description:"CoW Protocol does not need to work with executed transactions in order for users to be able to trade. The smart contract architecture is composed of an allowance manager and a settlement smart contract. The combination of these two contracts allow the protocol to offer users gas-free trades because it works with off-chain orders submitted via signed messages.",source:"@site/docs/overview/signed-orders.md",sourceDirName:"overview",slug:"/overview/signed-orders",permalink:"/docs-v2/docs/overview/signed-orders",draft:!1,unlisted:!1,editUrl:"https://github.com/cowprotocol/docs/tree/main/docs/overview/signed-orders.md",tags:[],version:"current",frontMatter:{}},c={},d=[];function h(e){const t=Object.assign({h1:"h1",p:"p",ul:"ul",li:"li"},(0,s.ah)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"signed-orders",children:"Signed Orders"}),"\n",(0,n.jsx)(t.p,{children:"CoW Protocol does not need to work with executed transactions in order for users to be able to trade. The smart contract architecture is composed of an allowance manager and a settlement smart contract. The combination of these two contracts allow the protocol to offer users gas-free trades because it works with off-chain orders submitted via signed messages."}),"\n",(0,n.jsx)(t.p,{children:"In order to benefit from off-chain order, the users first need to approve the vault relayer contract to execute the signed orders on their behalf. This means that the only transaction to be executed by the user in which they will have to pay a gas fee, is the token approval. Once you approve your funds for spending on the protocol, you can submit orders via signed messages that contain the trade's details, such as limit price, amount, timestamp, and so on."}),"\n",(0,n.jsx)(t.p,{children:"CoW Protocol is able to work with signed messages because it bases its mechanism in batch auctions. After the users have submitted their signed order, the solvers check the order submission and include them in the batch auction that the trade fits best. Once a trade order, aka signed message, has been included in a batch, the solvers send the transaction to the settlement contract, which checks with the allowance manager if such signed order has been given the approval to be spent. The combination of these two smart contracts allow CoW Protocol to work with off-chain order submission, as ultimately, the user has the guarantee that the settlement contract will not be able to spend any funds that have not previously been approved in the allowance manager contract. To sum up, the CoW Protocol smart contracts guarantee the users that:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Funds can only be transferred if a trader has approved GPv2 and signed an order to sell the given token for another"}),"\n",(0,n.jsx)(t.li,{children:"Limit prices and amounts of the signed order will always be satisfied"}),"\n",(0,n.jsx)(t.li,{children:"Signed orders have an expiry date, can be cancelled on-chain, and not be replayed"}),"\n",(0,n.jsx)(t.li,{children:"Only solvers subject to slashing can execute the batch auction settlement"}),"\n",(0,n.jsx)(t.li,{children:"Smooth transaction management, in the case of multisignature wallets, as once the first signature is done, the minimum price shown is guaranteed. If the protocol can find the promised price no matter when the rest of the signatures are done, the trade will be executed, if not, the order will simply expire without any cost for the trading participants."}),"\n"]})]})}const l=function(e={}){const{wrapper:t}=Object.assign({},(0,s.ah)(),e.components);return t?(0,n.jsx)(t,Object.assign({},e,{children:(0,n.jsx)(h,e)})):h(e)}},11151:(e,t,o)=>{o.d(t,{Zo:()=>i,ah:()=>r});var n=o(67294);const s=n.createContext({});function r(e){const t=n.useContext(s);return n.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const a={};function i({components:e,children:t,disableParentContext:o}){let i;return i=o?"function"==typeof e?e({}):e||a:r(e),n.createElement(s.Provider,{value:i},t)}}}]);