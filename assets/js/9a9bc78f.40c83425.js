"use strict";(self.webpackChunkcow_docs=self.webpackChunkcow_docs||[]).push([[8760],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>h});var o=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,o)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,o,a=function(e,t){if(null==e)return{};var r,o,a={},n=Object.keys(e);for(o=0;o<n.length;o++)r=n[o],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(o=0;o<n.length;o++)r=n[o],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=o.createContext({}),l=function(e){var t=o.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},u="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var r=e.components,a=e.mdxType,n=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(r),d=a,h=u["".concat(c,".").concat(d)]||u[d]||f[d]||n;return r?o.createElement(h,i(i({ref:t},p),{},{components:r})):o.createElement(h,i({ref:t},p))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var n=r.length,i=new Array(n);i[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<n;l++)i[l]=r[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,r)}d.displayName="MDXCreateElement"},72850:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>f,frontMatter:()=>n,metadata:()=>s,toc:()=>l});var o=r(87462),a=(r(67294),r(3905));const n={},i="The Basics of ERC-1271",s={unversionedId:"tutorials/how-to-place-erc-1271-smart-contract-orders/the-basics-of-erc-1271",id:"tutorials/how-to-place-erc-1271-smart-contract-orders/the-basics-of-erc-1271",title:"The Basics of ERC-1271",description:'While this works for EOAs, which have private keys, it does not work for Smart Contracts, and specifically Smart Contract Wallets. This is because Smart Contracts have no "private keys", to use for elliptic curve cryptography. Meaning, that Smart Contracts really be used for ECDSA signing. In order to work around this, a different signature is needed that does not depend on elliptic curve cryptography.',source:"@site/docs/tutorials/how-to-place-erc-1271-smart-contract-orders/the-basics-of-erc-1271.md",sourceDirName:"tutorials/how-to-place-erc-1271-smart-contract-orders",slug:"/tutorials/how-to-place-erc-1271-smart-contract-orders/the-basics-of-erc-1271",permalink:"/docs-v2/docs/tutorials/how-to-place-erc-1271-smart-contract-orders/the-basics-of-erc-1271",draft:!1,editUrl:"https://github.com/cowprotocol/docs/tree/main/docs/tutorials/how-to-place-erc-1271-smart-contract-orders/the-basics-of-erc-1271.md",tags:[],version:"current",frontMatter:{}},c={},l=[],p={toc:l},u="wrapper";function f(e){let{components:t,...r}=e;return(0,a.kt)(u,(0,o.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"the-basics-of-erc-1271"},"The Basics of ERC-1271"),(0,a.kt)("p",null,'While this works for EOAs, which have private keys, it does not work for Smart Contracts, and specifically Smart Contract Wallets. This is because Smart Contracts have no "private keys", to use for elliptic curve cryptography. Meaning, that Smart Contracts really be used for ECDSA signing. In order to work around this, a different signature is needed that does not depend on elliptic curve cryptography.'),(0,a.kt)("p",null,"The solution was to standardise a new form of on-chain signature verification for Smart Contracts: ",(0,a.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1271"},"ERC-1271"),". This is a simple standard that requires Smart Contracts that want to perform signature verification to implement a ",(0,a.kt)("inlineCode",{parentName:"p"},"isValidSignature")," method:"),(0,a.kt)("figure",null,(0,a.kt)("img",{src:"https://lh4.googleusercontent.com/jyTXFIF5mfZG8pZOIXx_4CKvi9XMrq39uR3RXgu_dLccgVVxfY43WgO2sJlJZe9JRn5V53Zfj857WmdBfef7shmtsNB86ui0goIPLCPvZlDKPUeHass7f7DOhBJlz3pc4dX6N7oxpvOm98DPGAPdGKUUQezQ-fD5tMf-ZzoU2C71pAiab_6xQymi2rIy",alt:""}),(0,a.kt)("figcaption",null)),(0,a.kt)("p",null,"The interface is very simple, but also incredibly flexible. The verifying Smart Contract would get passed in the 32-byte hash that it wants to verify along with an implementation dependant arbitrary length byte array. This arbitrary length byte array allows all kinds of data to be encoded and passed in, making signature verification extremely powerful. Also, since this is just a Smart Contract ",(0,a.kt)("inlineCode",{parentName:"p"},"CALL"),", the logic that verifies the signature can be arbitrary and make use of any on-chain state that it wants."),(0,a.kt)("p",null,"With respect to CoW Protocol orders, the flow now becomes:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Like before, prepare your order, i.e. the structured order data"),(0,a.kt)("li",{parentName:"ol"},"Like before, hash this structured data into a 32-byte digest"),(0,a.kt)("li",{parentName:"ol"},"Unlike before, call the ",(0,a.kt)("inlineCode",{parentName:"li"},"isValidSignature")," on the Smart Contract signer instead of performing the usual ECDSA signature recovery and validation")),(0,a.kt)("figure",null,(0,a.kt)("img",{src:"https://lh3.googleusercontent.com/vDMQVWDF_1NhqK7a9JMaLL-0UF0AYHZHnhVGXwqopuNtujWbpOB55bXZJZgQfqVQWgQxWSfkLSzigJp8dRyFN41mH7qtzzNxO0YxA9mQamz8BMeVdSMgpqIQUWH91y5oHtjEDeyINE2oPWj7oB_Q-jmuQ6EzxagBsP68YipCjgHx-1YbILK5BI91AODS",alt:""}),(0,a.kt)("figcaption",null)))}f.isMDXComponent=!0}}]);